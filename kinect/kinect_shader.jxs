<jittershader name="kinect_shader"> 
	<param name="rgb" type="int" default="0" />
	<param name="rgb_map" type="int" default="1" />
	
	<param name="T" type="vec3" default="0. 0. 0." />
	<param name="R1" type="vec3" default="1. 0. 0." />
	<param name="R2" type="vec3" default="0. 1. 0." />
	<param name="R3" type="vec3" default="0. 0. 1." />
	<param name="R" type="mat3" default="1. 0. 0. 0. 1. 0. 0. 0. 1." />
	
	<language name="glsl" version="1.0">
		<bind param="rgb_map" program="vp" />
		<bind param="T" program="vp" />
		<bind param="R" program="vp" />
		<bind param="rgb" program="fp" />

		<program name="vp" type="vertex">
<![CDATA[
#version 120
#extension GL_ARB_texture_rectangle : enable

varying vec2 texcoord0;

uniform sampler2D rgb_map;

uniform vec3 T;
uniform mat3 R;

vec2 dim = vec2(640, 480);

void main() {	
	vec4 vertex = gl_Vertex;
	
	// convert to RGBDemo system:
	vec3 v = vec3(vertex.x, -vertex.y, -vertex.z);
	
	// first, move the point into the RGB camera's perspective:
	vec3 v2 = R * (v - T);
	
	// next remove depth (vec2)
	// v3 is the location of the 3D depth point on the RGB image plane:
	vec2 ndc = v2.xy / v2.z;

	// we'll use this to index our pre-calculated RGB distortion map
	// v3 is NDC, but we want a texture coordinate in 0..1:
	// NOTE: our rgb_map specifies NDC coordinates in the [0.5, 0.5] range
	// so we don't need to scale ndc, just shift it to the center:
	vec2 t = 0.5 + ndc;
	
	// now get warped texture coordinate from the map:
	texcoord0 = texture2D(rgb_map, t).xy;
	
	gl_Position = gl_ModelViewProjectionMatrix * vertex; //ftransform();
}
]]>		
		</program>
		<program name="fp" type="fragment">
<![CDATA[
#version 120
#extension GL_ARB_texture_rectangle : enable
	
// texcoords
varying vec2 texcoord0;

// samplers
uniform sampler2D rgb;

// entry point
void main() {      
	gl_FragColor = texture2D(rgb, texcoord0); 
}
]]>		
		</program>
	</language> 
</jittershader>